---
layout: post
title: Health System
subtitle: GSoC Week 5 update
js: [/js/github-buttons.js, /js/required.js]
image: /img/oreonhealth.png
ext-js: https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js
css: [/css/required.css, /css/github-buttons.css]
---

## Oreon Health System
Week 5 involved working on the _Oreon Health System_ which encompasses logic (currently just) related to the reduction in health of the Oreon based on the situation. The initial implementation considers `hunger` as a parameter for this reduction i.e.
an Oreon that has been hungry for a while and cannot find a _Diner_ in the village will lose health over time, also notifying the player about its "plight" every once in a while. Every time the `needs_food` node is hit in the Oreon's behavior tree
 and the Oreon  cannot find a _DIner_ in the village the `OreonHealthSystem` is triggered. If there are no tasks available in the village, then the huger check node is hit every time the BT is run, i.e this would lead to a deduction in the Oreon health parameter
every tick, which would mean a hungry Oreon would have a rather short _lifespan_. I thought of two probable solutions for this:
1. Reduce the health every tick but by a very small quantity, so it seems that Oreon can fight hunger for a long time.
2. Use a variable to keep track of the last check and decide whether to run the HealthSystem logic based on the time elapsed.  
I decided to go with the second approach, as the first approach would be rather resource intensive considering that the HealthSystem logic would be run every time the game updates, which in turn leads to fetching the `OreonAttributeComponent`, changing a field
, replicating this change over the network every tick. So, I added a `lastHungerCheck` field to the component and use this decide whether to go ahead with the reduction or not.
#### What happens when Oreon health hits zero?
An obvious question which was just lurking around the corner while I was working on the health deduction logic. So, I had to destroy the Oreon entity, but this would lead to Oreons just outright vanish from the world, not an elegant solution. Luckily, there are already implemented
animations for the die sequence in the [Oreons](https://github.com/Terasology/Oreons/tree/master/assets/animations) module. Now it came down to how to run this animation once and destroy the Oreon entity after. In order to accomplish the above the effect I added a 
`OreonDeathSystem`.
## Oreon Death System
A rather grim topic :D  
This system handles the destruction of the Oreon entity after it has reached zero health. The challenge was to let the death animation play and trigger the `destroy()` method for the Oreon entity after it has ended. The logic behind this is first of all the `Behavior` component is removed
so that the Oreon stops looking for any tasks, then all the animations from its skeletal mesh are removed and the ones defined in the `DieComponent` in the Oreon prefabs are attached. Now, to calculate the duration of the animation I used the `getFrameCount()` method(code snippet
below) and multiplied with the time required for each frame, for every animation defined in the pool in the `DieComponent`. 
```java
    float lifespan = 0;
    for (MeshAnimation meshAnimation : skeletalMeshComponent.animationPool) {
        lifespan += meshAnimation.getTimePerFrame() * (meshAnimation.getFrameCount() - 1);
    }
```
This lifespan is then added to the current game time to get the time of death for the Oreon which is stored in a field defined in a `DieAnimationRunningComponent` which
is then added to this Oreons. The `update()`
method of a `UpdateSubscriberSystem` is called every the game updates, so this method in the Death System checks if the game time is past the death time for the all the entities which have a `DieAnimationRunningComponent` and destroys the corresponding entity.
```java
    @Override
    public void update(float delta) {
        float currentTime = time.getGameTime();

        for (EntityRef oreon : entityManager.getEntitiesWith(DeathAnimationRunningComponent.class)) {
            DeathAnimationRunningComponent deathAnimationComponent = oreon.getComponent(DeathAnimationRunningComponent.class);

            //if the death time has already passed
            if (deathAnimationComponent.deathTime < currentTime) {
                oreon.destroy();
            }
        }
    }
```

<figure>
<img src="oreondead.png" alt="Oreon Dead">
<figcaption>A fallen Oreon</figcaption>
</figure>


#### Some other minor bug fixes
I also came across a minor bug while testing for another GSoC project under the org the Record and Replay project which enables you to record all the events in the game that the player experiences and then run them later. I ran a saved game with MOO enabled to test the 
recording though the project is still in an initial state and does not support all events required in the module, I did come across a bug. The [`HoldingComponent`](/2018-05-27-GSoCWeek2#HoldingSystem) was attached to the player using the `onPlayerSpawn()` method, so
every time the player is spawned a Holding component would be attached to their entity, though this was fine when starting new games, playing an already saved game would lead to a new Holding for the player every time a saved game is started, so the Oreons already
spawned would be looking
for tasks in a different holding than the one the player is adding tasks to. The fix for this was pretty easy in comparison to the impact it had on the gameplay logic, it involved just adding a check for the component if it is already attached to the player entity and only add if not found.  


<div class="collapsiblecontainer">
<div class="collapsibleheader"> What is a game tick?</div>
<div class="collapsiblecontent">

</div>
</div>

  
  